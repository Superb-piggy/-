# 第一讲 操作系统导论

## 1.1 为什么引入操作系统

只有硬件组成的及其叫--裸机

==操作系统==就是在计算机硬件上的第一层==软件==，是最基本最重要的系统软件

一个计算机上各部分的关系图如下：

![image-20230621215015556](D:/猪猪的文件/演示/img/image-20230621215015556.png)

## 1.2 OS的目标和作用

### 1.2.1 OS的目标

* 方便性
* 有效性
* 可扩展性

方便对当前系统做改进

* 开放性

### 1.2.2 OS的作用

* OS作为用户和计算机硬件系统的接口
* OS作为计算机资源的管理者（处理器，存储器，IO，信息）
* OS实现了对计算机资源的抽象（其实就是更方便用户使用了，用户无需对深层原理有所了解）

## 1.3 OS的发展过程

### 1.3.1 无OS的计算机系统

人工操作

将数据手动送入，然后启动计算机，运算完毕后才可以进行下一次。

缺点：

* 用户独占全机
* CPU等待人工操作



脱机输入/输出

![image-20230621230052149](D:/猪猪的文件/演示/img/image-20230621230052149.png)

### 1.3.2 单道批处理系统

单道批处理指一条通道，批量处理

把一批作业以脱机方式输入到磁带上，在监督程序控制下使这批作业一个接一个地连续处理

特征：

* 自动性：自动地逐个依次进行
* 顺序性：顺序进入，完成顺序不变
* 单道性：仅有一道程序运行

缺点：

资源利用不充分，如CPU运行不充分，内存利用部分

### 1.3.3 多道批处理系统

* 用户提交的作业事先存放在外存上，形成“后备队列”
* 作业调度程序按一定算法从后备中选择==若干==作业调入内存，使它们共享CPU和系统中的各种资源

优势：

* 提高了CPU的利用率
* 提高内存和IO设备的利用率
* 增加了系统的吞吐量

特征：

* 多道性：多道程序并发执行
* 无序性：先进入可能后完成，后进入可能先完成
* 调度性：作业从调度到完成，需要经过两种调度：==作业调度==和==进程调度==

优缺点：

* 资源利用率高
* 系统吞吐量大
* 周转时间长
* 无交互能力



多道批处理系统需要解决的问题

* 处理机管理
* 内存管理
* IO设备管理
* 文件管理
* 作业管理

### 1.3.4 分时系统

一台主机上连有多个带有显示器和键盘的终端，各用户可以交互式使用计算机，共享资源

需要解决的关键问题：

* 及时接收：分时多路复用
* 及时处理：驻留内存

这就要求有：

用户作业不可以先进入磁盘再调入内存

不允许一个作业长期占用处理机

应该规定每个作业只运行一个很短的时间（称为时间片）

特征：

![image-20230624191842181](D:/猪猪的文件/演示/img/image-20230624191842181.png)

### 1.3.5 实时系统

实时系统指系统可以及时响应外部事件的请求，在规定时间内完成该事件的处理，并控制所有实时任务协调一致的运行

![image-20230621232739329](D:/猪猪的文件/演示/img/image-20230621232739329.png)

### 1.3.6 微机操作系统

单用户单任务操作系统

单用户多任务操作系统

多用户多任务操作系统

### 1.3.7 多处理机操作系统

![image-20230621233044336](D:/猪猪的文件/演示/img/image-20230621233044336.png)

### 1.3.8 网络操作系统

![image-20230621233153266](D:/猪猪的文件/演示/img/image-20230621233153266.png)

![image-20230621233158904](D:/猪猪的文件/演示/img/image-20230621233158904.png)

### 1.3.9 分布式操作系统

![image-20230621233407628](D:/猪猪的文件/演示/img/image-20230621233407628.png)

### 1.3.10 嵌入式操作系统

![image-20230621233441670](D:/猪猪的文件/演示/img/image-20230621233441670.png)

## 1.4 OS的定义与基本特征

### 1.4.1 OS的定义

操作系统是一组控制和管理计算机硬件和软件资源，合理地对各类作业进行调度，以及方便用户使用的程序的集合

### 1.4.2 OS的基本特征

#### 1. 并发

并发性指宏观上看有多个程序同时运行，微观上单处理机每一时刻只能有一道程序执行，所以微观上实质是分时地交替执行

并行：两个或多个事件在同一时刻发生

并发：两个或多个事件在同一时间间隔内发生

#### 2. 共享

共享指系统中资源可供内存中多个并发执行的进程共同使用。

* 互斥共享 临界资源
* 同时访问方式  非临界资源



并发和共享是操作系统的两个最基本的特征，它们互为存在条件。

![image-20230621234032447](D:/猪猪的文件/演示/img/image-20230621234032447.png)

#### 3.虚拟

![image-20230621235253456](D:/猪猪的文件/演示/img/image-20230621235253456.png)

#### 4.异步性

![image-20230621235340197](D:/猪猪的文件/演示/img/image-20230621235340197.png)

## 1.5 操作系统的主要功能

### 1.5.1 处理机管理功能

![image-20230621235522853](D:/猪猪的文件/演示/img/image-20230621235522853.png)

==处理机的分配和运行都是以进程为基本单位== 

进程和线程的区别

### 1.5.2 存储器管理

![image-20230621235812025](D:/猪猪的文件/演示/img/image-20230621235812025.png)

### 1.5.3 设备管理功能

![image-20230621235829856](D:/猪猪的文件/演示/img/image-20230621235829856.png)

### 1.5.4 文件管理

![image-20230621235842672](D:/猪猪的文件/演示/img/image-20230621235842672.png)

### 1.5.5 用户接口

![image-20230621235902105](D:/猪猪的文件/演示/img/image-20230621235902105.png)

## 1.6 操作系统的结构设计

### 无结构的OS

### 模块化OS结构

![image-20230622001721261](D:/猪猪的文件/演示/img/image-20230622001721261.png)

跟函数一样，各功能分开来

![image-20230622001757981](D:/猪猪的文件/演示/img/image-20230622001757981.png)

在这种情况下，错一个就整体瘫痪。



### 1.6.3 分层OS结构

![image-20230622001928652](D:/猪猪的文件/演示/img/image-20230622001928652.png)

==单向调用==

![image-20230622002006960](D:/猪猪的文件/演示/img/image-20230622002006960.png)

这个原则很重要，最重要的要放到最下面，只有它崩溃整个系统才崩溃。提供了一种可靠性



### 1.6.4 微内核OS结构

![image-20230622002453033](D:/猪猪的文件/演示/img/image-20230622002453033.png)

![image-20230622002505833](D:/猪猪的文件/演示/img/image-20230622002505833.png)

![image-20230622003142513](D:/猪猪的文件/演示/img/image-20230622003142513.png)

![image-20230622003240603](D:/猪猪的文件/演示/img/image-20230622003240603.png)

# 第二讲 接口和系统调用

# 第三讲 进程管理

## 3.1 进程的基本概念

进程和线程的关系如下：

![image-20230622005614658](D:/猪猪的文件/演示/img/image-20230622005614658.png)

线程是调度的最小单位

进程是分配资源的最小单位

### 3.1.1 前趋图

![image-20230622005736887](D:/猪猪的文件/演示/img/image-20230622005736887.png)

举例子：

![image-20230622005757912](D:/猪猪的文件/演示/img/image-20230622005757912.png)

### 3.1.2 程序顺序执行

![image-20230622122434959](D:/猪猪的文件/演示/img/image-20230622122434959.png)

以程序为单位和以指令为单位

![image-20230622122726054](D:/猪猪的文件/演示/img/image-20230622122726054.png)

### 3.1.3 程序的并发执行

![image-20230622122823354](D:/猪猪的文件/演示/img/image-20230622122823354.png)

![image-20230622123201193](D:/猪猪的文件/演示/img/image-20230622123201193.png)

![image-20230622123432367](D:/猪猪的文件/演示/img/image-20230622123432367.png)

==失去封闭性==，==不可再现性==

举个例子：

![image-20230622123541169](D:/猪猪的文件/演示/img/image-20230622123541169.png)

### 3.1.4 进程的基本概念

进程是程序在一个数据集上的运行过程

![image-20230622123829065](D:/猪猪的文件/演示/img/image-20230622123829065.png)

进程=程序+数据+PCB

进程和程序的关系和区别：

进程是程序的执行，是动态的概念，有生命周期；

程序是指令集合，是静态的永久存在

一个程序可以对应多个进程

一个进程也可以拥有多个程序

## 3.2 进程的描述

### 3.2.1 进程控制块

PCB属于一种数据结构

里面包含了进程的各种信息，包括：

* 进程标识符
* 处理机状态
* 进程调度信息
* 进程控制信息

### 3.2.2 PCB的组织方式

即在系统中，PCB是怎么放置的

#### 1. 链接方式

![image-20230622124529519](D:/猪猪的文件/演示/img/image-20230622124529519.png)

#### 2.索引方式

![image-20230622124551936](D:/猪猪的文件/演示/img/image-20230622124551936.png)

## 3.3 进程的控制

### 3.3.1 进程的基本状态

就绪：已经分配到除CPU外的所有资源，只要再获得CPU就可以立即执行

执行：已获得CPU，正在执行

阻塞：正在执行的进程由于发生某事件而无法继续执行（资源获取不到）便变为阻塞状态

创建：已分配PCB，但是还没有分配其他资源

终止：结束，但是依旧保存有它的数据供其他进程收集，一旦完成收集，则删除该进程

挂起：

![image-20230622142210119](D:/猪猪的文件/演示/img/image-20230622142210119.png)

### 3.3.2 进程状态转换

![image-20230622142413187](D:/猪猪的文件/演示/img/image-20230622142413187.png)

![image-20230622142424124](D:/猪猪的文件/演示/img/image-20230622142424124.png)

### 3.3.3 进程控制原语

![image-20230622142649467](D:/猪猪的文件/演示/img/image-20230622142649467.png)

==原语的执行具有不可分割性==



create：

![image-20230622142715924](D:/猪猪的文件/演示/img/image-20230622142715924.png)



kill：

![image-20230622142951529](D:/猪猪的文件/演示/img/image-20230622142951529.png)

block：

![image-20230622143010811](D:/猪猪的文件/演示/img/image-20230622143010811.png)

wakeup：

![image-20230622143141877](D:/猪猪的文件/演示/img/image-20230622143141877.png)

## 3.4 进程的互斥和同步

由于资源的共享，存在两种制约关系

**互斥和同步**

### 3.4.1 进程间制约关系

比如说打印机，当两个进程都需要使用打印机时，该如何分配，先后顺序？

### 3.4.2 进程互斥

临界资源：一段时间内仅允许一个进程访问

临界区：不允许并发进程交叉执行的一段程序

互斥：不允许两个及以上的共享临界资源的并发进程同时访问临界区，这叫互斥

互斥执行的原则：

![image-20230622144331133](D:/猪猪的文件/演示/img/image-20230622144331133.png)



解决互斥问题的方法：

#### peterson算法

对一个临界资源设置flag[]

如果flag[i]为1，说明该资源被i占用



硬件解决互斥问题：

==**信号量机制**==

![image-20230622145933088](D:/猪猪的文件/演示/img/image-20230622145933088.png)

仅能由互斥控制原语进行操作

![image-20230622150215348](D:/猪猪的文件/演示/img/image-20230622150215348.png)

wait进入，如果有资源则-1，用完之后signal将资源+1



![image-20230622150234996](D:/猪猪的文件/演示/img/image-20230622150234996.png)

整型的是先判断有没有再执行+1-1

计数型是只要申请则-1，让后将其加入到申请者列表中，然后阻塞该进程



**信号量集机制：**

信号量为一个集合

可以同时为一个进程分配多个资源

...

### 3.4.3 进程同步

![image-20230622151012089](D:/猪猪的文件/演示/img/image-20230622151012089.png)

并发进程的执行结果互为对方的执行条件，从而限制执行速度

这叫直接制约

互斥叫间接制约



同步的进程执行顺序需要有一定的要求



![image-20230622151539843](D:/猪猪的文件/演示/img/image-20230622151539843.png)

私有信号量和公有信号量



信号量解决同步问题：

![image-20230622151705903](D:/猪猪的文件/演示/img/image-20230622151705903.png)



一个示例：

![image-20230622151821761](D:/猪猪的文件/演示/img/image-20230622151821761.png)

![image-20230622151827908](D:/猪猪的文件/演示/img/image-20230622151827908.png)

## 3.5 经典进程的互斥同步问题

### 3.5.1 生产者消费者问题

#### 一个生产者一个消费者一个缓存区

![image-20230622152855011](D:/猪猪的文件/演示/img/image-20230622152855011.png)

一个生产者一个消费者n个缓存区

![image-20230622153104987](D:/猪猪的文件/演示/img/image-20230622153104987.png)

### 3.5.2 哲学家进餐问题

### 3.5.3 读者写者问题

### 3.5.4 理发师问题

### 3.5.5 管程机制

## 3.6 进程通信

### 3.6.1 进程通信的类型

==共享存储器通信==：

共享数据结构的通信方式；

共享存储区的通信方式

==管道通信==：

![image-20230622161941834](D:/猪猪的文件/演示/img/image-20230622161941834.png)

==消息传递通信==

![image-20230622162452691](D:/猪猪的文件/演示/img/image-20230622162452691.png)

感觉不是太重要...



### 3.6.5 客户/服务器通信

## 3.7 线程

进程是资源分配的基本单位

线程是处理机任务调度和执行的基本单位



引入线程可以减少进程转换的资源耗费

![image-20230622163343294](D:/猪猪的文件/演示/img/image-20230622163343294.png)



多线程编程的优点：

![image-20230622163421706](D:/猪猪的文件/演示/img/image-20230622163421706.png)



### 3.7.3 进程与线程的比较

![image-20230622164540233](D:/猪猪的文件/演示/img/image-20230622164540233.png)



线程和进程差不多，都有执行就绪阻塞

### 3.7.6 线程的分类

#### 内核级线程

![image-20230622172231464](D:/猪猪的文件/演示/img/image-20230622172231464.png)

优点：

![image-20230622204159615](D:/猪猪的文件/演示/img/image-20230622204159615.png)

#### 用户级线程

![image-20230622204354822](D:/猪猪的文件/演示/img/image-20230622204354822.png)

#### 组合式线程

![image-20230622204420839](D:/猪猪的文件/演示/img/image-20230622204420839.png)

多对一：

![image-20230622204546337](D:/猪猪的文件/演示/img/image-20230622204546337.png)

一对一：

![image-20230622204558596](D:/猪猪的文件/演示/img/image-20230622204558596.png)

多对多：

![image-20230622204623843](D:/猪猪的文件/演示/img/image-20230622204623843.png)

线程池：

![image-20230622204927157](D:/猪猪的文件/演示/img/image-20230622204927157.png)



# 第四讲 处理机调度与死锁

## 4.1 处理机调度的分级模型

### 4.1.1 作业和作业的状态转换

![image-20230622210212532](D:/猪猪的文件/演示/img/image-20230622210212532.png)

![image-20230622210233713](D:/猪猪的文件/演示/img/image-20230622210233713.png)

以上为==作业和进程的关系==



![image-20230622210341525](D:/猪猪的文件/演示/img/image-20230622210341525.png)



![image-20230622211326562](D:/猪猪的文件/演示/img/image-20230622211326562.png)

首先进入==外存==

![image-20230622211346023](D:/猪猪的文件/演示/img/image-20230622211346023.png)

提交是还未全部进入外存，收容是已经完全进入外存

![image-20230622211417925](D:/猪猪的文件/演示/img/image-20230622211417925.png)

从外存选作业进入内存，被选中的分配资源，处于执行状态

![image-20230622211457689](D:/猪猪的文件/演示/img/image-20230622211457689.png)

作业完成，资源尚未完全回收，处于完成状态



### 4.1.2 处理机调度的层次

#### 1.作业调度

![image-20230622211616129](D:/猪猪的文件/演示/img/image-20230622211616129.png)

负责从外存选作业进内存，并分配资源和回收资源

#### 2.交换调度

![image-20230622212137560](D:/猪猪的文件/演示/img/image-20230622212137560.png)

内外存交换

#### 3.进程调度

从内存中选取就绪状态的进程占用处理机

![image-20230622212222247](D:/猪猪的文件/演示/img/image-20230622212222247.png)

#### 4.线程调度

为线程分配CPU



### 4.1.3 处理机调度的目标

![image-20230622213501922](D:/猪猪的文件/演示/img/image-20230622213501922.png)

![image-20230622213523744](D:/猪猪的文件/演示/img/image-20230622213523744.png)



### 4.1.4 作业调度

![image-20230622213610440](D:/猪猪的文件/演示/img/image-20230622213610440.png)

![image-20230622213635339](D:/猪猪的文件/演示/img/image-20230622213635339.png)

### 4.1.5 进程调度

![image-20230622221035784](D:/猪猪的文件/演示/img/image-20230622221035784.png)

进程调度可分为可剥夺和非剥夺方式



## 4.2 调度算法

### 4.2.1 先来先服务调度算法

![image-20230622221232110](D:/猪猪的文件/演示/img/image-20230622221232110.png)

### 4.2.2 短作业优先调度

![image-20230622221612298](D:/猪猪的文件/演示/img/image-20230622221612298.png)

缺点：

![image-20230622221629772](D:/猪猪的文件/演示/img/image-20230622221629772.png)

### 4.2.3 高优先权优先调度算法

#### 非抢占式

#### 抢占式

优先权可以从开始设定之后就不变

也可以随着时间进行改变

![image-20230622221747280](D:/猪猪的文件/演示/img/image-20230622221747280.png)

![image-20230622221803200](D:/猪猪的文件/演示/img/image-20230622221803200.png)



### 4.2.4 高响应比优先调度算法

![image-20230622221831191](D:/猪猪的文件/演示/img/image-20230622221831191.png)

这种算法比较公平，缺点是每次调度都要计算相应比

### 4.2.5 基于时间片的轮转调度算法

实际上就是短时间内轮着来



### 4.2.6 多级反馈队列调度算法

 ![image-20230622225252815](D:/猪猪的文件/演示/img/image-20230622225252815.png)



## 4.3 实时调度

### 4.3.1 实现实时调度的基本条件

![image-20230622231437609](D:/猪猪的文件/演示/img/image-20230622231437609.png)

![image-20230622231557485](D:/猪猪的文件/演示/img/image-20230622231557485.png)

![image-20230622231752150](D:/猪猪的文件/演示/img/image-20230622231752150.png)

![image-20230622231814411](D:/猪猪的文件/演示/img/image-20230622231814411.png)

![image-20230622231822756](D:/猪猪的文件/演示/img/image-20230622231822756.png)

![image-20230622231829337](D:/猪猪的文件/演示/img/image-20230622231829337.png)

### 4.3.2 实时调度算法的分类

![image-20230622231954332](D:/猪猪的文件/演示/img/image-20230622231954332.png)

### 4.3.3 常用的几种实时调度算法

![image-20230622232054861](D:/猪猪的文件/演示/img/image-20230622232054861.png)

![image-20230622232114523](D:/猪猪的文件/演示/img/image-20230622232114523.png)



## 4.5 死锁

### 4.5.1 产生死锁的原因

竞争资源

### 4.5.2 产生死锁的条件

![image-20230622233746914](D:/猪猪的文件/演示/img/image-20230622233746914.png)

### 4.5.3 处理死锁的基本方法

![image-20230622233841270](D:/猪猪的文件/演示/img/image-20230622233841270.png)

### 4.5.4 预防死锁

破坏一个或多个条件

![image-20230622234007264](D:/猪猪的文件/演示/img/image-20230622234007264.png)

![image-20230622234014405](D:/猪猪的文件/演示/img/image-20230622234014405.png)

![image-20230622234023904](D:/猪猪的文件/演示/img/image-20230622234023904.png)

### 4.5.5 避免死锁--银行家算法

![image-20230622234548550](D:/猪猪的文件/演示/img/image-20230622234548550.png)



银行家算法可以找到是否存在合适的序列避免死锁

![image-20230623002548392](D:/猪猪的文件/演示/img/image-20230623002548392.png)

Work为现在可以支配的资源

need为该进程需要的资源

allocation为已经分配的资源



找到合理序列就是安全的



## 4.6 死锁的检测和解除

### 4.6.1 死锁的检测

资源分配图

![image-20230623003350897](D:/猪猪的文件/演示/img/image-20230623003350897.png)

![image-20230623003358024](D:/猪猪的文件/演示/img/image-20230623003358024.png)



Warshell循环



## 4.7 死锁的解除

剥夺资源

撤销进程

鸵鸟算法



# 第五讲 存储器管理

## 5.1 存储器的层次结构

![image-20230623004203531](D:/猪猪的文件/演示/img/image-20230623004203531.png)

### 5.1.4 逻辑地址和物理地址

![image-20230623005138883](D:/猪猪的文件/演示/img/image-20230623005138883.png)



对于这种逻辑地址和物理地址之间的差异，我们要进行重定位

![image-20230623005211573](D:/猪猪的文件/演示/img/image-20230623005211573.png)

静态重定位和动态重定位



## 5.2 程序的装入和链接

### 5.2.1 程序的装入

![image-20230623005330380](D:/猪猪的文件/演示/img/image-20230623005330380.png)

### 5.2.2 程序的链接

![image-20230623005518842](D:/猪猪的文件/演示/img/image-20230623005518842.png)

链接就是将用到的都组合到一起



![image-20230623005629192](D:/猪猪的文件/演示/img/image-20230623005629192.png)



## 5.3 连续分配方式

### 5.3.1 单一连续分配

![image-20230623005740652](D:/猪猪的文件/演示/img/image-20230623005740652.png)



### 5.3.2 固定分区分配

![image-20230623005826519](D:/猪猪的文件/演示/img/image-20230623005826519.png)

![image-20230623005838480](D:/猪猪的文件/演示/img/image-20230623005838480.png)



![image-20230623005913436](D:/猪猪的文件/演示/img/image-20230623005913436.png)

### 5.3.3 动态分区分配

![image-20230623005937032](D:/猪猪的文件/演示/img/image-20230623005937032.png)

![image-20230623010025921](D:/猪猪的文件/演示/img/image-20230623010025921.png)

![image-20230623010822295](D:/猪猪的文件/演示/img/image-20230623010822295.png)



当一个进程需要分配空间时，可以采用多种算法。

![image-20230623010908632](D:/猪猪的文件/演示/img/image-20230623010908632.png)



回收内存的时候，根据不同情况，做出不同的回收策略。

![image-20230623011005953](D:/猪猪的文件/演示/img/image-20230623011005953.png)

当内存块很多，我们需要采取一些措施快速查找适合的内存。



![image-20230623011113174](D:/猪猪的文件/演示/img/image-20230623011113174.png)

![image-20230623011221094](D:/猪猪的文件/演示/img/image-20230623011221094.png)

![image-20230623011321183](D:/猪猪的文件/演示/img/image-20230623011321183.png)

![image-20230623011328183](D:/猪猪的文件/演示/img/image-20230623011328183.png)



### 5.3.4 可重定位分区分配

在分配资源时，不一定能做到完全契合，所以总会产生一些内存碎片，所以我们可以将碎片整合。

![image-20230623011447030](D:/猪猪的文件/演示/img/image-20230623011447030.png)



与动态一样，仅仅加了紧凑功能。

### 5.3.5 对换

![image-20230623120944288](D:/猪猪的文件/演示/img/image-20230623120944288.png)



![image-20230623121257627](D:/猪猪的文件/演示/img/image-20230623121257627.png)

![image-20230623121342663](D:/猪猪的文件/演示/img/image-20230623121342663.png)



## 5.4 基本分页存储管理方式

### 5.4.1 页面和页表

![image-20230623121600824](D:/猪猪的文件/演示/img/image-20230623121600824.png)

![image-20230623121812584](D:/猪猪的文件/演示/img/image-20230623121812584.png)

![image-20230623121853624](D:/猪猪的文件/演示/img/image-20230623121853624.png)

页是逻辑地址的概念

块是物理地址的概念



### 5.4.2 地址变换机构

页表机制下，如何将逻辑地址转换到物理地址？

#### 基本的地址转换机构

![image-20230623133700428](D:/猪猪的文件/演示/img/image-20230623133700428.png)

举例：

![image-20230623133747657](D:/猪猪的文件/演示/img/image-20230623133747657.png)



#### 具有快表的地址转换机构

![image-20230623134234114](D:/猪猪的文件/演示/img/image-20230623134234114.png)

普通的地址转换需要访问两次内存

快表是访问高速缓存，访问高速缓存的时间原低于访问内存

在快表中找到了，就只访问一次内存

未找到，则将访问页表，将页表放到快表，然后再写



### 5.4.3 两级和多级页表

#### 两级页表

![image-20230623134702022](D:/猪猪的文件/演示/img/image-20230623134702022.png)

![image-20230623134829557](D:/猪猪的文件/演示/img/image-20230623134829557.png)



#### 多级页表

![image-20230623140441141](D:/猪猪的文件/演示/img/image-20230623140441141.png)



#### 倒排页表

![image-20230623140637643](D:/猪猪的文件/演示/img/image-20230623140637643.png)



### 5.4.4 分页存储空间的分配和去配

![image-20230623140850403](D:/猪猪的文件/演示/img/image-20230623140850403.png)



## 5.5 基本分段存储管理方式

### 5.5.2 分段系统的基本原理

![image-20230623140958073](D:/猪猪的文件/演示/img/image-20230623140958073.png)

![image-20230623141029815](D:/猪猪的文件/演示/img/image-20230623141029815.png)

![image-20230623141111964](D:/猪猪的文件/演示/img/image-20230623141111964.png)

段与段之间不要求连续

因为有段表，所以也得有地址变换机构



### 5.5.3 信息共享

![image-20230623141222679](D:/猪猪的文件/演示/img/image-20230623141222679.png)

![image-20230623141319629](D:/猪猪的文件/演示/img/image-20230623141319629.png)

由于设置有信息共享，所以减少了内存的消耗

### 5.5.4 段页式存储管理方式

![image-20230623142420603](D:/猪猪的文件/演示/img/image-20230623142420603.png)

最上面是段 段内分页 



![image-20230623142519045](D:/猪猪的文件/演示/img/image-20230623142519045.png)



## 5.6 虚拟存储器的基本概念



![image-20230623142558648](D:/猪猪的文件/演示/img/image-20230623142558648.png)

常规存储器无法解决太大放不下的问题

虚拟存储器可以解决，实现方法为已经执行过的可以删掉

![image-20230623143503648](D:/猪猪的文件/演示/img/image-20230623143503648.png)

![image-20230623143659326](D:/猪猪的文件/演示/img/image-20230623143659326.png)



### 5.6.2 虚拟存储器的实现方法

![image-20230623144804118](D:/猪猪的文件/演示/img/image-20230623144804118.png)

![image-20230623144822221](D:/猪猪的文件/演示/img/image-20230623144822221.png)

### 5.6.3 虚拟存储器的特征

![image-20230623144851550](D:/猪猪的文件/演示/img/image-20230623144851550.png)



## 5.7 请求分页存储管理方式

### 5.7.1 请求分页的硬件支持

![image-20230623145038110](D:/猪猪的文件/演示/img/image-20230623145038110.png)

要有合适的数据结构，才能支持完成功能。

![image-20230623145131246](D:/猪猪的文件/演示/img/image-20230623145131246.png)

![image-20230623145340463](D:/猪猪的文件/演示/img/image-20230623145340463.png)



### 5.7.3 调页策略

![image-20230623145445566](D:/猪猪的文件/演示/img/image-20230623145445566.png)

![image-20230623145455533](D:/猪猪的文件/演示/img/image-20230623145455533.png)



## 5.8  置换算法

### 5.8.1 最佳置换算法和先进先出置换算法



![image-20230623145624310](D:/猪猪的文件/演示/img/image-20230623145624310.png)



### 5.8.2 最近最久未使用LRU置换算法

![image-20230623145713453](D:/猪猪的文件/演示/img/image-20230623145713453.png)



### 5.8.3 最少使用页面置换算法LFU

![image-20230623150256166](D:/猪猪的文件/演示/img/image-20230623150256166.png)

### 5.8.4 最近没使用页面置换算法

![image-20230623150317800](D:/猪猪的文件/演示/img/image-20230623150317800.png)

### 5.8.5 Clock置换算法

![image-20230623150342644](D:/猪猪的文件/演示/img/image-20230623150342644.png)

### 5.8.6 页面缓冲算法PBA

![image-20230623150648481](D:/猪猪的文件/演示/img/image-20230623150648481.png)

## 5.9 抖动和工作集

![image-20230623150806447](D:/猪猪的文件/演示/img/image-20230623150806447.png)

![image-20230623151655784](D:/猪猪的文件/演示/img/image-20230623151655784.png)



工作集过大，容易出现抖动

![image-20230623151759092](D:/猪猪的文件/演示/img/image-20230623151759092.png)



## 5.10 请求分段存储管理方式

![image-20230623151830809](D:/猪猪的文件/演示/img/image-20230623151830809.png)

![image-20230623151857204](D:/猪猪的文件/演示/img/image-20230623151857204.png)

![image-20230623151911289](D:/猪猪的文件/演示/img/image-20230623151911289.png)

![image-20230623151922223](D:/猪猪的文件/演示/img/image-20230623151922223.png)

### 5.10.2 分段的共享和保护

![image-20230623151933483](D:/猪猪的文件/演示/img/image-20230623151933483.png)

![image-20230623152018732](D:/猪猪的文件/演示/img/image-20230623152018732.png)

![image-20230623152030038](D:/猪猪的文件/演示/img/image-20230623152030038.png)

![image-20230623152036615](D:/猪猪的文件/演示/img/image-20230623152036615.png)



# 第六讲 文件管理

## 6.1 文件和文件系统

### 6.1.2 文件类型和文件系统模型

![image-20230623204713354](D:/猪猪的文件/演示/img/image-20230623204713354.png)

![image-20230623204809188](D:/猪猪的文件/演示/img/image-20230623204809188.png)

![image-20230623204900364](D:/猪猪的文件/演示/img/image-20230623204900364.png)

### 6.1.3 文件操作

![image-20230623204930802](D:/猪猪的文件/演示/img/image-20230623204930802.png)

## 6.2 文件的逻辑结构

![image-20230623205011826](D:/猪猪的文件/演示/img/image-20230623205011826.png)

![image-20230623205117893](D:/猪猪的文件/演示/img/image-20230623205117893.png)

### 6.2.1 文件逻辑结构的类型

#### 1. 有结构文件

![image-20230623205240624](D:/猪猪的文件/演示/img/image-20230623205240624.png)

#### 2.无结构文件

![image-20230623205320116](D:/猪猪的文件/演示/img/image-20230623205320116.png)

#### 3.顺序文件

![image-20230623205358881](D:/猪猪的文件/演示/img/image-20230623205358881.png)

![image-20230623205450708](D:/猪猪的文件/演示/img/image-20230623205450708.png)

#### 4. 索引文件

![image-20230623205519354](D:/猪猪的文件/演示/img/image-20230623205519354.png)

#### 5.索引顺序文件

![image-20230623205622188](D:/猪猪的文件/演示/img/image-20230623205622188.png)



#### 6. Hash文件

![image-20230623205644500](D:/猪猪的文件/演示/img/image-20230623205644500.png)

## 6.3 文件目录

### 6.3.1 文件控制块和索引结点

FCB  文件控制块

![image-20230623210521368](D:/猪猪的文件/演示/img/image-20230623210521368.png)



![image-20230623211627019](D:/猪猪的文件/演示/img/image-20230623211627019.png)

![image-20230623212104164](D:/猪猪的文件/演示/img/image-20230623212104164.png)

#### 以下是磁盘索引结点

![image-20230623212117423](D:/猪猪的文件/演示/img/image-20230623212117423.png)

#### 以下为内存索引结点

![image-20230623212335646](D:/猪猪的文件/演示/img/image-20230623212335646.png)



### 6.3.2 目录结构

#### 单级目录结构

![image-20230623212523823](D:/猪猪的文件/演示/img/image-20230623212523823.png)

#### 两级目录结构

![image-20230623212550931](D:/猪猪的文件/演示/img/image-20230623212550931.png)

![image-20230623212632672](D:/猪猪的文件/演示/img/image-20230623212632672.png)

### 多级目录结构

![image-20230623212706470](D:/猪猪的文件/演示/img/image-20230623212706470.png)

### 5.3.3 目录查询技术

![image-20230623212757795](D:/猪猪的文件/演示/img/image-20230623212757795.png)

#### 线性检索法

![image-20230623213220369](D:/猪猪的文件/演示/img/image-20230623213220369.png)

#### Hash方法

![image-20230623213406029](D:/猪猪的文件/演示/img/image-20230623213406029.png)

![image-20230623213421329](D:/猪猪的文件/演示/img/image-20230623213421329.png)

## 6.4 外存分配方式

![image-20230623213522668](D:/猪猪的文件/演示/img/image-20230623213522668.png)



### 6.4.1 连续分配

![image-20230623213732546](D:/猪猪的文件/演示/img/image-20230623213732546.png)

![image-20230623213750633](D:/猪猪的文件/演示/img/image-20230623213750633.png)

![image-20230623213758257](D:/猪猪的文件/演示/img/image-20230623213758257.png)

### 6.4.2 链接分配

![image-20230623213820891](D:/猪猪的文件/演示/img/image-20230623213820891.png)

![image-20230623215312401](D:/猪猪的文件/演示/img/image-20230623215312401.png)

比如：

![image-20230623215402736](D:/猪猪的文件/演示/img/image-20230623215402736.png)

![image-20230623215416589](D:/猪猪的文件/演示/img/image-20230623215416589.png)

![image-20230623215428342](D:/猪猪的文件/演示/img/image-20230623215428342.png)

![image-20230623215620386](D:/猪猪的文件/演示/img/image-20230623215620386.png)

应该是FCB中一个表项就记录了整个循环



### 6.4.3 索引分配

![image-20230623215714493](D:/猪猪的文件/演示/img/image-20230623215714493.png)

![image-20230623215751127](D:/猪猪的文件/演示/img/image-20230623215751127.png)

![image-20230623215908399](D:/猪猪的文件/演示/img/image-20230623215908399.png)



#### 单级索引

![image-20230623215940634](D:/猪猪的文件/演示/img/image-20230623215940634.png)

#### 两级索引

![image-20230623220007382](D:/猪猪的文件/演示/img/image-20230623220007382.png)



应用举例：

![image-20230623220140419](D:/猪猪的文件/演示/img/image-20230623220140419.png)



#### 混合索引分配方式

![image-20230623220313364](D:/猪猪的文件/演示/img/image-20230623220313364.png)

![image-20230623220337981](D:/猪猪的文件/演示/img/image-20230623220337981.png)

![image-20230623220352560](D:/猪猪的文件/演示/img/image-20230623220352560.png)



## 6.5 文件存储空间的管理

![image-20230623220634481](D:/猪猪的文件/演示/img/image-20230623220634481.png)

### 6.5.1 空间表法和空闲链表法

![image-20230623220747840](D:/猪猪的文件/演示/img/image-20230623220747840.png)

表上可以看出哪里空缺，空缺的起始位和块数





![image-20230623224805127](D:/猪猪的文件/演示/img/image-20230623224805127.png)

![image-20230623224817021](D:/猪猪的文件/演示/img/image-20230623224817021.png)

这个链上只存空闲，但是不合并，所以为文件分配时，如果大小不合适还得继续往下找



### 6.5.2 位示图法

![image-20230623225106156](D:/猪猪的文件/演示/img/image-20230623225106156.png)

![image-20230623225126605](D:/猪猪的文件/演示/img/image-20230623225126605.png)



### 6.5.3 成组链接法

![image-20230623231212757](D:/猪猪的文件/演示/img/image-20230623231212757.png)

![image-20230623231308280](D:/猪猪的文件/演示/img/image-20230623231308280.png)

![image-20230623231316023](D:/猪猪的文件/演示/img/image-20230623231316023.png)

![image-20230623231444952](D:/猪猪的文件/演示/img/image-20230623231444952.png)

![image-20230623231450418](D:/猪猪的文件/演示/img/image-20230623231450418.png)·

## 6.6 文件共享与文件保护

### 6.6.1 基于索引结点的共享方式

![image-20230623231604670](D:/猪猪的文件/演示/img/image-20230623231604670.png)

![image-20230623232606834](D:/猪猪的文件/演示/img/image-20230623232606834.png)

可以理解为，索引结点是唯一的，将索引结点共享可以实现文件的共享

### 6.6.2 利用符号链实现文件共享

![image-20230623232717067](D:/猪猪的文件/演示/img/image-20230623232717067.png)

### 6.6.3 文件保护



# 第七讲 设备管理

## 7.1 IO系统

## 7.2 IO设备

### 7.2.1 IO设备的类型

![image-20230627003713374](D:/猪猪的文件/演示/img/image-20230627003713374.png)



### 设备与控制器之间的接口

![image-20230627003835754](D:/猪猪的文件/演示/img/image-20230627003835754.png)

### 7.2.2 IO 设备控制器

![image-20230627004051518](D:/猪猪的文件/演示/img/image-20230627004051518.png)

![image-20230627004100780](D:/猪猪的文件/演示/img/image-20230627004100780.png)



由三部分组成：

* 处理机与设备控制器的接口
* 设备控制器与设备的接口
* IO逻辑--用于实现对设备的控制

### 7.2.3 IO通道

![image-20230627004240529](D:/猪猪的文件/演示/img/image-20230627004240529.png)



## 7.3 IO控制方式

### 7.3.1 程序IO方式

![image-20230627004423574](D:/猪猪的文件/演示/img/image-20230627004423574.png)

### 7.3.2 中断驱动IO控制方式

![image-20230627004528896](D:/猪猪的文件/演示/img/image-20230627004528896.png)



### 7.3.3 直接存储器访问IO控制方式

![image-20230627004621503](D:/猪猪的文件/演示/img/image-20230627004621503.png)



### 7.3.4 IO通道控制方式

![image-20230627005001373](D:/猪猪的文件/演示/img/image-20230627005001373.png)



## 7.4 缓冲管理

### 7.4.1 缓冲的引入

![image-20230627005121042](D:/猪猪的文件/演示/img/image-20230627005121042.png)



### 7.4.2 单缓冲和双缓冲

![image-20230627005239392](D:/猪猪的文件/演示/img/image-20230627005239392.png)

T和C可以并行

![image-20230627005252798](D:/猪猪的文件/演示/img/image-20230627005252798.png)



![image-20230627005639292](D:/猪猪的文件/演示/img/image-20230627005639292.png)

明显比上面那个更好，这样可以都并行

![image-20230627005744464](D:/猪猪的文件/演示/img/image-20230627005744464.png)



### 7.4.3 循环缓冲

![image-20230627010103538](D:/猪猪的文件/演示/img/image-20230627010103538.png)

![image-20230627010356143](D:/猪猪的文件/演示/img/image-20230627010356143.png)

### 7.4.4 缓冲池

![image-20230627010754034](D:/猪猪的文件/演示/img/image-20230627010754034.png)

![image-20230627010823618](D:/猪猪的文件/演示/img/image-20230627010823618.png)

收容输入：让空间给IO输入信息

提取输入：计算程序对输入信息计算

收容输出：计算结果输入

提取输出：把结果读出来



## 7.5 设备分配

![image-20230627011347334](D:/猪猪的文件/演示/img/image-20230627011347334.png)

### 7.5.1 设备分配中的数据结构

![image-20230627011441438](D:/猪猪的文件/演示/img/image-20230627011441438.png)

![image-20230627011452915](D:/猪猪的文件/演示/img/image-20230627011452915.png)



### 7.5.2 设备分配时应考虑的因素

![image-20230627012008999](D:/猪猪的文件/演示/img/image-20230627012008999.png)

### 7.5.3 独占设备的分配程序

![image-20230627012133466](D:/猪猪的文件/演示/img/image-20230627012133466.png)



### 7.5.4 SPOOLing技术

假脱机操作

虚拟打印机





## 7.6 IO软件系统层次模型

### 7.6.1 IO软件系统功能

![image-20230627012436597](D:/猪猪的文件/演示/img/image-20230627012436597.png)

### 7.6.2 IO软件系统层次模型

![image-20230627012955303](D:/猪猪的文件/演示/img/image-20230627012955303.png)

也是分层调用



### 7.6.3 中断处理程序

![image-20230627013118660](D:/猪猪的文件/演示/img/image-20230627013118660.png)

![image-20230627013329458](D:/猪猪的文件/演示/img/image-20230627013329458.png)

![image-20230627013407681](D:/猪猪的文件/演示/img/image-20230627013407681.png)



### 7.6.4 设备驱动程序

![image-20230627013802931](D:/猪猪的文件/演示/img/image-20230627013802931.png)

![image-20230627014005216](D:/猪猪的文件/演示/img/image-20230627014005216.png)

![image-20230627014050801](D:/猪猪的文件/演示/img/image-20230627014050801.png)

### 7.6.5 设备独立性



## 7.7 磁盘存储器管理

### 7.7.1 磁盘性能简述

![image-20230627015153880](D:/猪猪的文件/演示/img/image-20230627015153880.png)



![image-20230627015216116](D:/猪猪的文件/演示/img/image-20230627015216116.png)

寻道+旋转延迟+传输



### 7.7.2 磁盘调度

![image-20230627015716937](D:/猪猪的文件/演示/img/image-20230627015716937.png)

![image-20230627015745558](D:/猪猪的文件/演示/img/image-20230627015745558.png)

![image-20230627015803769](D:/猪猪的文件/演示/img/image-20230627015803769.png)

![image-20230627015835567](D:/猪猪的文件/演示/img/image-20230627015835567.png)

![image-20230627015901049](D:/猪猪的文件/演示/img/image-20230627015901049.png)

![image-20230627015918159](D:/猪猪的文件/演示/img/image-20230627015918159.png)

![image-20230627015958534](D:/猪猪的文件/演示/img/image-20230627015958534.png)

![image-20230627020008960](D:/猪猪的文件/演示/img/image-20230627020008960.png)

![image-20230627020037804](D:/猪猪的文件/演示/img/image-20230627020037804.png)



### 提高磁盘IO速度的途径

![image-20230627020147831](D:/猪猪的文件/演示/img/image-20230627020147831.png)

![image-20230627020201073](D:/猪猪的文件/演示/img/image-20230627020201073.png)

