# 数据库简介

## 数据库系统的组成

* 数据库
* 数据库管理系统
* 数据库应用程序

![image-20230627230715764](D:/猪猪的文件/演示/img/image-20230627230715764.png)





数据库管理系统：

![image-20230627230859602](D:/猪猪的文件/演示/img/image-20230627230859602.png)



## 数据库系统体系结构

数据库系统的三级结构和两级独立性

![image-20230627231141591](D:/猪猪的文件/演示/img/image-20230627231141591.png)



三级结构：

* 用户级   外模式
* 概念级  概念模式
* 物理级 内模式



![image-20230627231629344](D:/猪猪的文件/演示/img/image-20230627231629344.png)



两级独立性：

* 逻辑独立性
* 物理独立性

![image-20230627231826583](D:/猪猪的文件/演示/img/image-20230627231826583.png)

![image-20230627231851003](D:/猪猪的文件/演示/img/image-20230627231851003.png)



==不是所有数据库系统都有三级结构两级独立性的特点==

## 大型数据库系统的类型

* 集中式数据库系统（一个库
* 分布式数据库系统（多个库



## 数据管理的阶段

* 书面文档，人工管理
* 计算机出现后，文件系统的方式
* 计算机硬件软件发展后，用数据库存储数据
* 数据库系统
* 高级数据库系统



## 数据库应用程序的体系结构类型

发展过程：

* 单层的数据库应用程序
* 两层的数据库应用程序
* 三层和多层的数据库应用程序



DBMS

![image-20230627233356245](D:/猪猪的文件/演示/img/image-20230627233356245.png)



![image-20230627233525184](D:/猪猪的文件/演示/img/image-20230627233525184.png)



![image-20230627233541916](D:/猪猪的文件/演示/img/image-20230627233541916.png)



![image-20230627233558753](D:/猪猪的文件/演示/img/image-20230627233558753.png)

![image-20230627233635305](D:/猪猪的文件/演示/img/image-20230627233635305.png)

![image-20230627233643093](D:/猪猪的文件/演示/img/image-20230627233643093.png)

![image-20230627233701275](D:/猪猪的文件/演示/img/image-20230627233701275.png)



# 关系模式与完整性

## 数据和信息

![image-20230628000218884](D:/猪猪的文件/演示/img/image-20230628000218884.png)



**数据描述：**

现实世界->信息世界->机器世界



信息世界的描述术语：

实体（客观存在的东西）

属性

实体键（能唯一标识该实体的属性或属性集，叫实体键）



机器世界的描述术语：

字段 记录 文件 记录键



## 实体-联系模型

![image-20230628000857852](D:/猪猪的文件/演示/img/image-20230628000857852.png)



三要素：实体，属性，联系

工具：ER图



实体间的关系抽象为联系，分为三种：

* 1：1
* 1：n
* m：n



### ER图

![image-20230628001410116](D:/猪猪的文件/演示/img/image-20230628001410116.png)

实体为长方形

属性为圆形

联系为菱形



![image-20230628001621476](D:/猪猪的文件/演示/img/image-20230628001621476.png)

组合属性，比如出生日期

联系也可以产生属性，比如选课联系下的成绩

实体键用下划线标识出



举例：

![image-20230628002759807](D:/猪猪的文件/演示/img/image-20230628002759807.png)



## 数据模型

![image-20230628003327365](D:/猪猪的文件/演示/img/image-20230628003327365.png)



数据模型 = 数据的组织方法 + 数据操作集合 + 数据完整性集合

* 层次模型
* 网状模型
* 关系模型



关系数据库的原理：（好像是下面这个板块里面的内容

![image-20230628003632170](D:/猪猪的文件/演示/img/image-20230628003632170.png)



## 关系数据模型简介

### 关系数据模型基本概念

![image-20230628003937370](D:/猪猪的文件/演示/img/image-20230628003937370.png)

关系模式指表项，表示可以为学生（学号，姓名...）

下面是关系（表）

![image-20230628004507291](D:/猪猪的文件/演示/img/image-20230628004507291.png)

一列叫一个属性

一行叫一个元组

每一个属性的取值范围叫域

![image-20230628004603441](D:/猪猪的文件/演示/img/image-20230628004603441.png)

关键字：唯一标识的属性

候选关键字

主关键字

外部关键字**



### 关系数据模型完整性约束规则

域完整性

实体完整性

引用完整性

用户自定义完整性

### 关系数据模型的数据操作

数据查询

数据插入

数据删除

数据修改



### 将实体联系模型转化为关系数据模型

![image-20230628005514723](D:/猪猪的文件/演示/img/image-20230628005514723.png)

规则总结：

* 实体有的属性，转化为关系数据模型后也要有，关键字还是关键字
* 联系如果有自身属性，也要转化为关系数据模型。并且该模型的属性包含自身属性，还要包含该联系相关的实体的主键，实体主键共同作为主关键字。
* 如果联系没有自身属性，则根据下面三种情况转化
* 如果是1:n，则将1侧的实体键变为属性加入N侧
* 如果是m:n，则建立一个新关系模式，关键字为双方的主键。
* 如果是1：1，采用上面任意一种。

示例：

![image-20230628005648148](D:/猪猪的文件/演示/img/image-20230628005648148.png)

关系数据模型里，也可以为主键加下划线



# 函数依赖与范式

## 规范化

关系数据库设计理论对数据库逻辑设计有重要的指导作用，它主要包括三个方面的内容：

* 数据依赖
* 范式
* 模式设计方法

其中数据依赖起着核心作用



举例：

![image-20230628111027834](D:/猪猪的文件/演示/img/image-20230628111027834.png)

![image-20230628111218242](D:/猪猪的文件/演示/img/image-20230628111218242.png)

![image-20230628111227131](D:/猪猪的文件/演示/img/image-20230628111227131.png)

![image-20230628111513786](D:/猪猪的文件/演示/img/image-20230628111513786.png)

![image-20230628111529445](D:/猪猪的文件/演示/img/image-20230628111529445.png)



## 函数依赖

![image-20230628113053031](D:/猪猪的文件/演示/img/image-20230628113053031.png)

![image-20230628113533388](D:/猪猪的文件/演示/img/image-20230628113533388.png)

有前提条件

### 分类和键

![image-20230628113614146](D:/猪猪的文件/演示/img/image-20230628113614146.png)

包含是平凡函数依赖

否则是非平凡函数依赖



![image-20230628114011828](D:/猪猪的文件/演示/img/image-20230628114011828.png)

![image-20230628114118077](D:/猪猪的文件/演示/img/image-20230628114118077.png)



## 范式

![image-20230628114328778](D:/猪猪的文件/演示/img/image-20230628114328778.png)

### 第一范式

每个属性都是不可分解的

那么该关系模式为第一范式

![image-20230628114610057](D:/猪猪的文件/演示/img/image-20230628114610057.png)

在这个里面，工资可以分割，课程也可以分割，转化为下面的样子。

### 第二范式

![image-20230628120708201](D:/猪猪的文件/演示/img/image-20230628120708201.png)

![image-20230628120812740](D:/猪猪的文件/演示/img/image-20230628120812740.png)

### 第三范式

![image-20230628120834477](D:/猪猪的文件/演示/img/image-20230628120834477.png)

### BC范式

![image-20230628121434871](D:/猪猪的文件/演示/img/image-20230628121434871.png)



## 关系模式的分解

![image-20230628131248664](D:/猪猪的文件/演示/img/image-20230628131248664.png)

![image-20230628131818038](D:/猪猪的文件/演示/img/image-20230628131818038.png)

![image-20230628131933516](D:/猪猪的文件/演示/img/image-20230628131933516.png)

## 题型1 判断范式

![image-20230628132424782](D:/猪猪的文件/演示/img/image-20230628132424782.png)

## 题型2 判断候选码

![image-20230628132713515](D:/猪猪的文件/演示/img/image-20230628132713515.png)



## 题型3 关系模式分解，符合第二范式

![image-20230628133102450](D:/猪猪的文件/演示/img/image-20230628133102450.png)

## 题型4 关系模式分解，符合第三范式

![image-20230628134013634](D:/猪猪的文件/演示/img/image-20230628134013634.png)



# 管理数据库

## 数据库存储结构

数据库文件：

* .mdf  主数据库文件
* .ndf   辅助数据库文件
* .ldf    事物日志文件





系统数据库：

* master
* model
* tempdb
* msdb

用户数据库：

* pubs
* Northwind



文件组：

？



# 使用SQL Server管理表

UNIQUE约束

check约束

标识列

FOREIGN KEY



# 关系代数



# 索引与查询优化



# SQL语句

## select

## DISTINCT

![image-20230628144321282](D:/猪猪的文件/演示/img/image-20230628144321282.png)

第一个是一个不能重复

第二个是一起不能重复，比如12 13是可以的

## TOP n

![image-20230628144357605](D:/猪猪的文件/演示/img/image-20230628144357605.png)



## INTO

![image-20230628150059120](D:/猪猪的文件/演示/img/image-20230628150059120.png)



## WHERE

![image-20230628150328736](D:/猪猪的文件/演示/img/image-20230628150328736.png)

order by 排序 默认是升序 DESC是降序 ASC是升序

where是条件



## and or not 

![image-20230628150510528](D:/猪猪的文件/演示/img/image-20230628150510528.png)



## between

![image-20230628150527373](D:/猪猪的文件/演示/img/image-20230628150527373.png)



##  is null 和 is not null

![image-20230628150552347](D:/猪猪的文件/演示/img/image-20230628150552347.png)

## in 和not in

![image-20230628150609081](D:/猪猪的文件/演示/img/image-20230628150609081.png)

## 模糊查询like %

![image-20230628150627885](D:/猪猪的文件/演示/img/image-20230628150627885.png)

## 下划线_单字符通配

![image-20230628152722018](D:/猪猪的文件/演示/img/image-20230628152722018.png)

## []区域单字符通配

![image-20230628152802795](D:/猪猪的文件/演示/img/image-20230628152802795.png)

## 聚合函数 max min count

where里面不可以加聚合函数

## groupby

按照某一项进行聚合

![image-20230628154737496](D:/猪猪的文件/演示/img/image-20230628154737496.png)



![image-20230628154352173](D:/猪猪的文件/演示/img/image-20230628154352173.png)

## having

对聚合函数的结果进行筛选

放在where的后面

且where的优先级大于having

![image-20230628154522320](D:/猪猪的文件/演示/img/image-20230628154522320.png)



## order by

![image-20230628154709983](D:/猪猪的文件/演示/img/image-20230628154709983.png)



## 内联接

![image-20230628160853440](D:/猪猪的文件/演示/img/image-20230628160853440.png)

![image-20230628160930854](D:/猪猪的文件/演示/img/image-20230628160930854.png)



## 外联接

![image-20230628161337602](D:/猪猪的文件/演示/img/image-20230628161337602.png)

![image-20230628161350281](D:/猪猪的文件/演示/img/image-20230628161350281.png)

![image-20230628161355623](D:/猪猪的文件/演示/img/image-20230628161355623.png)



## 删除delete

![image-20230628161608422](D:/猪猪的文件/演示/img/image-20230628161608422.png)

## insert

![image-20230628163150768](D:/猪猪的文件/演示/img/image-20230628163150768.png)

这种插入比较慢，可以用下面的方法

![image-20230628163404871](D:/猪猪的文件/演示/img/image-20230628163404871.png)



![image-20230628163213247](D:/猪猪的文件/演示/img/image-20230628163213247.png)

![image-20230628163305664](D:/猪猪的文件/演示/img/image-20230628163305664.png)

## update

![image-20230628163431324](D:/猪猪的文件/演示/img/image-20230628163431324.png)



## 函数

![image-20230628163733606](D:/猪猪的文件/演示/img/image-20230628163733606.png)



## declare

![image-20230628163755933](D:/猪猪的文件/演示/img/image-20230628163755933.png)

![image-20230628164511753](D:/猪猪的文件/演示/img/image-20230628164511753.png)

![image-20230628164547887](D:/猪猪的文件/演示/img/image-20230628164547887.png)



## 视图

视图就是表

![image-20230628164717169](D:/猪猪的文件/演示/img/image-20230628164717169.png)

在这里上面就是视图的创建，内部就是查询语句

创建好了之后，我们也可以直接from使用



视图的优点：



DDL



## 存储过程

![image-20230628165847666](D:/猪猪的文件/演示/img/image-20230628165847666.png)

类似于函数

在存储过程中，形参可以带默认值参数

![image-20230628170209189](D:/猪猪的文件/演示/img/image-20230628170209189.png)

## 触发器

![image-20230628170546549](D:/猪猪的文件/演示/img/image-20230628170546549.png)

创建触发器

on后面加在哪个表上添加触发器

for后面加操作

后面是操作执行后执行的语句

![image-20230628170657297](D:/猪猪的文件/演示/img/image-20230628170657297.png)

deleted里面可以存有删除的东西

![image-20230628171305342](D:/猪猪的文件/演示/img/image-20230628171305342.png)

同理inserted也一样



## 游标

一行一行的指针

```
-- 查询商业书籍：显示1993-1994年总销量，同时显示作者数量  --*
declare @mytitleid varchar(100), @mytitle varchar(100),@myqty int , @myauthorcount int
declare c_query_19931994_business_qty_sum cursor for
	select title_id ,title from titles
	where type = 'business'
create table #tempreport(
	[TitleID][varchar](50),
	[Title][varchar](500),
	[Sumsale][int],
	[Authorcount][int]
	)on [primary]
open c_query_19931994_business_qty_sum
fetch next from c_query_19931994_business_qty_sum
into @mytitleid , @mytitle
while @@FETCH_STATUS = 0
begin 
	--print '书编号' + @mytitleid + '书名：' + @mytitle
	set @myqty = (
	select sum(qty) from sales
	where ord_date between '1993-1-1' and '1994-12-31' and title_id = @mytitleid)
	set @myauthorcount = (select count(*) from titleauthor where title_id = @mytitleid)
	insert into #tempreport values (@mytitleid,@mytitle,@myqty,@myauthorcount)
	fetch next from c_query_19931994_business_qty_sum
	into @mytitleid,@mytitle
end

close c_query_19931994_business_qty_sum
deallocate c_query_19931994_business_qty_sum
select * from #tempreport 
order by Sumsale DESC
drop table #tempreport
```

第一行声明变量

第二行创建游标，名字为c_query_19931994_business_qty_sum

该游标指向了select搜索出来的表的第一行（表项头），然后创建了一个临时表，打开游标，将游标第二行数据（第一行有数据的）赋值给两个变量，然后判断下一行是否还有数据，如果有，则为另外两个变量赋值，赋值后插入临时表中，游标移动到下一行

最后关闭游标 释放内存，释放临时表内存



# 关系代数

![image-20230629100323159](D:/猪猪的文件/演示/img/image-20230629100323159.png)

![image-20230629100354328](D:/猪猪的文件/演示/img/image-20230629100354328.png)

![image-20230629100451795](D:/猪猪的文件/演示/img/image-20230629100451795.png)

在这里是以每一行数据为运算单位的

![image-20230629100524991](D:/猪猪的文件/演示/img/image-20230629100524991.png)



## 选择

![image-20230629100801383](D:/猪猪的文件/演示/img/image-20230629100801383.png)

σ下面为检索标准

括号里面为表



## 投影

![image-20230629101104126](D:/猪猪的文件/演示/img/image-20230629101104126.png)

比如这个例三里面，下标为Sname和Sdept

表示选中这两列

Student为在此表中操作



## 连接

![image-20230629101807586](D:/猪猪的文件/演示/img/image-20230629101807586.png)

==注意是从笛卡尔积里面选取==

等值连接

==自然连接==

等值连接和自然连接本质一样，但是自然连接去重了重复表项



## 除

![image-20230629102421263](D:/猪猪的文件/演示/img/image-20230629102421263.png)

![image-20230629102600649](D:/猪猪的文件/演示/img/image-20230629102600649.png)

![image-20230629103047617](D:/猪猪的文件/演示/img/image-20230629103047617.png)



# DDL

create关键字

![image-20230629104707892](D:/猪猪的文件/演示/img/image-20230629104707892.png)



alter关键字

![image-20230629104744266](D:/猪猪的文件/演示/img/image-20230629104744266.png)



drop关键字

![image-20230629105139433](D:/猪猪的文件/演示/img/image-20230629105139433.png)



# 索引与查询优化

![image-20230629110606246](D:/猪猪的文件/演示/img/image-20230629110606246.png)



![image-20230629110623751](D:/猪猪的文件/演示/img/image-20230629110623751.png)

![image-20230629110643703](D:/猪猪的文件/演示/img/image-20230629110643703.png)

簇索引在叶子结点里面存储了数据

![image-20230629110944270](D:/猪猪的文件/演示/img/image-20230629110944270.png)

每张表只能有一个簇索引，且需要第一个建立

主键是聚簇索引的良好候选（不一定是最好）

当列常需要排序或按范围查询时，应使用簇索引



非簇索引

![image-20230629111535389](D:/猪猪的文件/演示/img/image-20230629111535389.png)

叶子节点储存的是表的行信息。

![image-20230629112043227](D:/猪猪的文件/演示/img/image-20230629112043227.png)



缺省设置创建的索引是非聚簇索引



![image-20230629112257101](D:/猪猪的文件/演示/img/image-20230629112257101.png)

![image-20230629112434586](D:/猪猪的文件/演示/img/image-20230629112434586.png)

填充因子即预留空间

一般0为很空

100为很满

20-80为宜



like和orderby 和 not会降低索引速度

